<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VistaNow - Private Streaming</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="index.css">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- AI & Video Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script crossorigin src="https://unpkg.com/@daily-co/daily-js"></script>
</head>
<body>
    <div id="container">
        <!-- Input video (hidden) -->
        <video id="input_video" playsinline></video>
        <!-- Output canvas (visible) -->
        <canvas id="output_canvas"></canvas>
    </div>

    <div id="controls">
        <div id="status">
            <span class="status-indicator" id="statusDot"></span>
            <span id="statusText">Initializing Privacy Engine...</span>
        </div>

        <!-- Mask Selection -->
        <div class="mask-options">
            <div class="mask-option selected" data-type="blur" title="Smart Blur">ðŸ’§</div>
            <div class="mask-option" data-type="pixel_high" title="Deep Pixelate">â¬›</div>
            <div class="mask-option" data-type="emoji_fox" title="Fox Mask">ðŸ¦Š</div>
            <div class="mask-option" data-type="emoji_cool" title="Cool Mask">ðŸ˜Ž</div>
        </div>

        <div class="control-group">
            <button id="startBtn" disabled>
                <span>ðŸš€ Go Live</span>
            </button>
            <button id="copyBtn" class="secondary hidden">
                <span>ðŸ”— Copy Link</span>
            </button>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const copyBtn = document.getElementById('copyBtn');
        const statusText = document.getElementById('statusText');
        const statusDot = document.getElementById('statusDot');
        
        // App State
        let state = {
            isStreamActive: false,
            maskType: 'blur', // blur, pixel_high, emoji_fox, emoji_cool
            facesDetected: false,
            callObject: null,
            roomUrl: null
        };

        // UI Event Listeners - Mask Selection
        document.querySelectorAll('.mask-option').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('.mask-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                state.maskType = opt.dataset.type;
            });
        });

        // --- Core Privacy Rendering Engine ---
        function onResults(results) {
            // 1. Setup Canvas
            if (canvasElement.width !== videoElement.videoWidth || canvasElement.height !== videoElement.videoHeight) {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
            }

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 2. Check Detections
            // If no faces found -> FAIL SAFE MODE (Blur entire screen)
            if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
                state.facesDetected = false;
                
                // Draw original image first
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
                
                // OVERLAY FULL SCREEN BLUR/OBFUSCATION
                canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.85)'; // Darken
                canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
                
                // Add Privacy Warning Text
                canvasCtx.font = "30px Inter";
                canvasCtx.fillStyle = "white";
                canvasCtx.textAlign = "center";
                canvasCtx.fillText("ðŸ™ˆ Privacy Shield Active", canvasElement.width/2, canvasElement.height/2);
                canvasCtx.font = "20px Inter";
                canvasCtx.fillStyle = "#94a3b8";
                canvasCtx.fillText("No face detected. Stream hidden.", canvasElement.width/2, canvasElement.height/2 + 40);
                
                updateStatus("Waiting for subject...", "warning");
            } else {
                state.facesDetected = true;
                updateStatus("Subject Protected & Live", "active");

                // 3. Draw Base Image
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

                // 4. Apply Masks to all faces
                for (const landmarks of results.multiFaceLandmarks) {
                    applyMask(landmarks, results.image);
                }
            }
            canvasCtx.restore();
        }

        function applyMask(landmarks, sourceImage) {
            // Calculate Bounding Box
            let xMin = 1, yMin = 1, xMax = 0, yMax = 0;
            for (const point of landmarks) {
                if (point.x < xMin) xMin = point.x;
                if (point.x > xMax) xMax = point.x;
                if (point.y < yMin) yMin = point.y;
                if (point.y > yMax) yMax = point.y;
            }

            const width = canvasElement.width;
            const height = canvasElement.height;
            const padding = 0.15; // Increased padding for safety
            
            xMin = Math.max(0, xMin - padding);
            yMin = Math.max(0, yMin - padding);
            xMax = Math.min(1, xMax + padding);
            yMax = Math.min(1, yMax + padding);

            const x = xMin * width;
            const y = yMin * height;
            const w = (xMax - xMin) * width;
            const h = (yMax - yMin) * height;

            canvasCtx.save();
            
            if (state.maskType === 'blur') {
                canvasCtx.beginPath();
                canvasCtx.ellipse(x + w/2, y + h/2, w/2, h/1.5, 0, 0, 2 * Math.PI);
                canvasCtx.clip();
                canvasCtx.filter = 'blur(30px)'; // Heavy blur
                canvasCtx.drawImage(sourceImage, 0, 0, width, height);
            } else if (state.maskType === 'pixel_high') {
                // Pixelate effect
                const pixelSize = 25;
                // Simple block out
                canvasCtx.fillStyle = '#0f172a';
                canvasCtx.fillRect(x, y, w, h);
                
                // Optional: Draw a "Sensor" text
                canvasCtx.fillStyle = 'white';
                canvasCtx.font = 'bold 20px Arial';
                canvasCtx.textAlign = 'center';
                canvasCtx.fillText('CENSORED', x + w/2, y + h/2);
            } else if (state.maskType.startsWith('emoji')) {
                // Draw Emoji
                const emoji = state.maskType === 'emoji_fox' ? 'ðŸ¦Š' : 'ðŸ˜Ž';
                canvasCtx.font = `${Math.max(w, h)}px serif`;
                canvasCtx.textAlign = 'center';
                canvasCtx.textBaseline = 'middle';
                canvasCtx.fillText(emoji, x + w/2, y + h/2);
            }

            canvasCtx.restore();
        }

        function updateStatus(text, type) {
            statusText.textContent = text;
            statusDot.className = `status-indicator ${type}`;
        }

        // --- Initialization ---
        const faceMesh = new FaceMesh({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
        }});
        
        faceMesh.setOptions({
            maxNumFaces: 3,
            refineLandmarks: true,
            minDetectionConfidence: 0.65, // Higher confidence needed
            minTrackingConfidence: 0.65
        });
        
        faceMesh.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        camera.start().then(() => {
            startBtn.disabled = false;
            updateStatus("Camera Ready. Select Mask.", "warning");
        });

        // --- Daily.co Logic ---
        startBtn.addEventListener('click', async () => {
             // Basic Demo Logic for now
            startBtn.disabled = true;
            startBtn.innerHTML = "<span>Connecting...</span>";
            
            const apiKey = prompt("Enter Daily.co API Key (Leave empty for demo):");
            let url = "";

            if (apiKey) {
                 try {
                    const response = await fetch('https://api.daily.co/v1/rooms', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({ properties: { exp: Math.round(Date.now() / 1000) + 3600 } })
                    });
                    const data = await response.json();
                    url = data.url;
                } catch(e) {
                    alert("Error creating room");
                    startBtn.disabled = false;
                    return;
                }
            } else {
                 url = prompt("Enter a Daily.co Room URL:", "https://your-domain.daily.co/test");
            }

            if (!url) {
                startBtn.disabled = false;
                startBtn.innerHTML = "<span>ðŸš€ Go Live</span>";
                return;
            }

            state.roomUrl = url;
            const stream = canvasElement.captureStream(30);
            
            try {
                // Initialize Daily
                state.callObject = DailyIframe.createCallObject();
                await state.callObject.join({
                    url: state.roomUrl,
                    videoSource: stream.getVideoTracks()[0],
                    audioSource: true
                });
                
                startBtn.classList.add('hidden');
                copyBtn.classList.remove('hidden');
                updateStatus("LIVE STREAMING (Protected)", "active");
                
            } catch (err) {
                console.error(err);
                alert("Could not join room: " + err.message);
                startBtn.disabled = false;
                startBtn.innerHTML = "<span>ðŸš€ Go Live</span>";
            }
        });

        copyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(state.roomUrl);
            const originalText = copyBtn.innerHTML;
            copyBtn.innerHTML = "<span>âœ¨ Copied!</span>";
            setTimeout(() => copyBtn.innerHTML = originalText, 2000);
        });

        // Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => navigator.serviceWorker.register('./service-worker.js'));
        }
    </script>
</body>
</html>
